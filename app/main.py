# app/main.py

from fastapi import FastAPI, Depends, HTTPException, UploadFile, File
from fastapi.responses import StreamingResponse
from app.schemas import QueryRequest, QueryResponse
from app.model import get_qa_chain
from app.dependencies import get_retriever, update_retriever
from app.retriever import load_and_process_pdf  # ✅ Fixed Import
from app.config import DATA_DIR, STREAMING_DELAY  # Import config variables
import asyncio
import os

app = FastAPI(title="Hybrid RAG API", version="1.0.0")

@app.post("/upload-pdf/")
async def upload_pdf(file: UploadFile = File(...)):
    """
    API endpoint to upload and process PDF files for retrieval.
    It updates the retriever dynamically with new documents.
    """
    # Ensure data directory exists
    os.makedirs(DATA_DIR, exist_ok=True)

    # Save the file
    file_path = os.path.join(DATA_DIR, file.filename)
    with open(file_path, "wb") as f:
        f.write(file.file.read())

    # Process the file and update the retriever
    try:
        documents = load_and_process_pdf(file_path)  # ✅ Uses the correct function
        updated_retriever = update_retriever([file_path])
        return {"message": f"File {file.filename} uploaded and retriever updated."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update retriever: {str(e)}")

async def generate_tokens(question: str, retriever):
    """
    Generator function that streams tokens as they are generated by the LLM.
    """
    if not retriever:
        yield "event: error\ndata: No retriever available. Upload a document first.\n\n"
        return
    
    qa_chain = get_qa_chain(retriever)

    # Retrieve relevant documents
    context_data = retriever._get_relevant_documents(question)

    input_data = {
        "context": "\n".join([doc.page_content for doc in context_data]),
        "query": question,
    }

    response = qa_chain(input_data)

    answer = response.get("result", "No result found.")

    # Stream response token by token
    for token in answer:
        yield f"data: {token}\n\n"
        await asyncio.sleep(STREAMING_DELAY)  # Configurable delay from `config.py`

    yield "event: end\ndata: [DONE]\n\n"

@app.post("/query", response_model=QueryResponse)
async def query_standard(request: QueryRequest, retriever=Depends(get_retriever)):
    """
    API endpoint to return the full response without streaming.
    """
    qa_chain = get_qa_chain(retriever)

    # Retrieve relevant documents
    context_data = retriever._get_relevant_documents(request.question)

    input_data = {
        "context": "\n".join([doc.page_content for doc in context_data]),
        "query": request.question,
    }

    response = qa_chain(input_data)
    answer = response.get("result", "No result found.")
    source_documents = response.get("source_documents", [])

    sources = [doc.metadata.get("source", "Unknown") for doc in source_documents]

    return QueryResponse(answer=answer, sources=sources)

@app.post("/query/stream")
async def query_stream(request: QueryRequest, retriever=Depends(get_retriever)):
    """
    API endpoint to stream query responses in real-time using SSE.
    """
    return StreamingResponse(generate_tokens(request.question, retriever), media_type="text/event-stream")
